;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;                               ps-file.lisp
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;  Copyright (c) Statistical Computing Laboratory
;;;                University of Waterloo
;;;                Canada.
;;;
;;;  This file is part of the Window-Basics package intended to provide a uniform
;;;  window environment for Common Lisp programming.
;;;  
;;;  For copyright information and history, see window-basics-copyright.lisp
;;;
;;;  Authors:
;;;    N.G. Bennett 1992
;;;    R.W. Oldford 1992
;;;     
;;;
;;; The following functions actually perform the writes to the various postscript files which
;;; are generated by the postscript draw functions.
;;;
;;;----------------------------------------------------------------------------------


(in-package :wb)

(eval-when (:compile-toplevel :load-toplevel :execute) (export  '(read-write concatenate-ps)))

#| ;moved to postscript-canavs.lsp 28AUG2023
(defparameter *ps-paper-width*
  612
  "Device independence parameter. Currently set to 8.5x11 paper only! Width=612/72"
  )

(defparameter *ps-paper-height*
  792
  "Device independence parameter. Currently set to 8.5x11 paper only! Height=792/72"
  )
|#

(defun read-write (input output)
  "Reads from input file and appends on output file."
  (with-open-file (ifile input
                         :direction :input
                         :if-does-not-exist :error)
    (with-open-file (ofile output
                         :direction :output 
                         :if-exists :append
                         :if-does-not-exist :create)
      (loop with line = (read-line ifile NIL NIL)
            while line
            do (write-line  line ofile)
            (setf line (read-line ifile NIL NIL))))))

(defun ps-setup (canvas)
  "This function sets up the color, background, line width, and font for the postscript canvas."
  (with-open-file (ofile (header-full-pathname canvas)
                         :direction :output 
                         :if-exists :supersede
                         :if-does-not-exist :create)
    (let* ((ver (quail-kernel::get-quail-release-info))
           (pi-info (postscript-info-of canvas))
           (xpixels (canvas-width canvas))
           (ypixels (canvas-height canvas))
           (xmargin (ps-horizontal-margin-of canvas))
           (ymargin (ps-vertical-margin-of canvas))
           (bbox-startx (+ xmargin (canvas-to-ps-x canvas 0)))
           (bbox-starty (+ ymargin (canvas-to-ps-y canvas 0)))
           (bbox-endx (+ xmargin (canvas-to-ps-x canvas xpixels)))
           (bbox-endy (+ ymargin (canvas-to-ps-y canvas ypixels))))
      (if (multiple-pages-p pi-info)
        (format ofile "~&%!PS-Adobe-3.0")
        (format ofile "~&%!PS-Adobe-3.0 EPSF-3.0"))
      (when (not (multiple-pages-p pi-info))
        (format ofile "~&%%BoundingBox:  ~a ~a ~a ~a"
              bbox-startx bbox-starty bbox-endx bbox-endy))
      (format ofile "~&%%Creator: Quail v.~a" (first ver))
      (when (second ver)
        (format ofile " ~a" (second ver)))
      (format ofile " of ~a~%" (third ver)))
      (format ofile "~&~%/ps_paper_width ~a def~%/ps_paper_height ~a def~%"
              *ps-paper-width* *ps-paper-height*))
  (toggle-includes canvas "Defaults")
  (read-write (include-file-of "defaults")
              (header-full-pathname canvas))
  (with-open-file (ofile (header-full-pathname canvas)
                         :direction :output 
                         :if-exists :append
                         :if-does-not-exist :create)
    (format ofile "~%/canvas_horizontal_margin ~a def~%/canvas_vertical_margin ~a def~%"
            (ps-horizontal-margin-of canvas)
            (ps-vertical-margin-of canvas)))
  (with-open-file (ofile (body-full-pathname canvas)
                         :direction :output 
                         :if-exists :append
                         :if-does-not-exist :create)
    (format ofile "~% ~A ~A ~A b" 
            (canvas-to-ps-red canvas (red-of (canvas-background-color canvas)))
            (canvas-to-ps-green canvas (green-of (canvas-background-color canvas)))
            (canvas-to-ps-blue canvas (blue-of (canvas-background-color canvas))))
    (format ofile "~%/~a findfont ~a scalefont setfont~%" 
            (get-ps-font-name canvas (canvas-font canvas))
            (* (canvas-font-size (canvas-font canvas))
               (floor (/ (+ (ps-x-scale-of canvas)
                            (ps-y-scale-of canvas)) 2))))
    (format ofile "~&"))
  (ps-set-pen-width canvas (pen-width-of canvas))
  (ps-set-pen-color canvas (pen-color-of canvas))
  )

(defmacro write-ps (canvas command-name &rest args)
  "This macro generates the postscript command for a given canvas command, ensures that the~
   correct function definitions have been included, and writes the command to the postscript~
   body file. args is either a bunch of individual arguments, OR a list with ALL the~
   arguments included. Either of these two forms will be processed correctly."
  `(let* ((my-args (list ,@args))
          (file-name (body-full-pathname ,canvas))
          (header-file (header-full-pathname ,canvas))
          (command-string (string-downcase (string (quote ,command-name)))))
     (when (listp (first my-args))
       (setf my-args (first my-args)))
     (unless (defaults-included-p ,canvas)
       (ps-setup ,canvas))
     (if (streamp file-name)
       (format file-name (concatenate 'string (format NIL "~&~8T ~{~a ~}" my-args)
                                      (format NIL " ~a" command-string)))
       (with-open-file (ofile file-name
                              :direction :output 
                              :if-exists :append
                              :if-does-not-exist :create)
         (if (include-command-p ,canvas command-string)
           (unless (command-included-p ,canvas command-string)
             (toggle-includes ,canvas command-string)
             (read-write (include-file-of command-string)
                         header-file)))
         (format ofile (concatenate 'string (format NIL "~&~8T ~{~a ~}" my-args)
                                    (format NIL " ~a" command-string)))))))

(defun toggle-includes (canvas command-name)
  "This function toggles the 'included' attribute of each postscript command as its definition~
   is included in the postscript header.  This ensures that each command definition gets added~
   only once to the postscript header."
  (let ((toggle-pair (assoc command-name (included-of canvas) :test #'string-equal)))
    (if toggle-pair
      (when (not (cdr toggle-pair))
        (setf (cdr toggle-pair) T))
      (quail-error "~s not found in the include list." command-name))))

(defun reset-includes (canvas)
  "This function resets all the 'included' attributes of each postscript command to NIL.
   It is used to reset the list when the header filename is changed."
  (mapcar #'(lambda (list) (setf (cdr list) NIL)) (included-of canvas)))

#| ; moved to postscript-canvas.lsp 28AUG20233
(defparameter *include-list*
  (list (cons "e"  NIL)
        (cons "fe" NIL)
        (cons "r"  NIL)
        (cons "fp" NIL)
        (cons "a"  NIL)
        (cons "fa" NIL)
        (cons "t"  NIL)
        (cons "l"  NIL)
        (cons "c"  NIL)
        (cons "i"  NIL)
;;        (cons "redraw" NIL)
        (cons "x"  NIL)
        (cons "y"  NIL)
        (cons "vshow" NIL)
        (cons "Outline Font Generation Procedures" NIL)
        (cons "Defaults" NIL))
  "This variable contains the list of commands which have command definitions in the~
   include files.  It also contains the status of these includable commands.  'T'~
   indicates that the command definition has been included and 'NIL' indicates that~
   the command definition has not been added to the postscript header file."
  )
  |#

(defun postscript-include (filename)
  "This function adds the correct full pathname to the names of the include files so that~
   the functions which use the names of the include files will be MCL independent."
  (concatenate 'string "zot" filename));(mk::fullpath-postscript) filename))

(defun include-file-of (ps-name)
  "This function returns the correct include file path and name for the postscript command~
   given in the command line."
  (cond
   ((string-equal ps-name "defaults")  (postscript-include "defaults.ps"))
   ((string-equal ps-name "e")         (postscript-include "ellipse.ps"))
   ((string-equal ps-name "fe")        (postscript-include "fellipse.ps"))
   ((string-equal ps-name "a")         (postscript-include "arc.ps"))
   ((string-equal ps-name "fa")        (postscript-include "farc.ps"))
   ((string-equal ps-name "r")         (postscript-include "rect.ps"))
   ((string-equal ps-name "fp")        (postscript-include "fpolygon.ps"))
   ((string-equal ps-name "t")         (postscript-include "drawto.ps"))
   ((string-equal ps-name "l")         (postscript-include "drawline.ps"))
   ((string-equal ps-name "c")         (postscript-include "frect.ps"))
   ((string-equal ps-name "i")         (postscript-include "invert.ps"))
   ((string-equal ps-name "x")         (postscript-include "canvasx.ps"))
   ((string-equal ps-name "y")         (postscript-include "canvasy.ps"))
   ((string-equal ps-name "vshow")     (postscript-include "vshow.ps"))
   ((string-equal ps-name "Outline Font Generation Procedures")
    (postscript-include "ofont.ps"))))

(defun defaults-included-p (canvas)
  "This function checks to see if the defaults section of the header file has been included.~
   It returns 'T' if the defaults have been included, and 'NIL' otherwise."
  (cdr (assoc "defaults" (included-of canvas) :test #'string-equal)))

(defun command-included-p (canvas command-name)
  "This function checks to see if a given command definition has been included in the postscript~
   header file.  It returns 'T' if the command has been included, and 'NIL' otherwise."
  (cdr (assoc command-name (included-of canvas) :test #'string-equal)))

(defun include-command-p (canvas command-name)
  "This function determines whether or not the given command name is an includable command.~
   It returns 'T' if the command is includable, and 'NIL' if not."
  (assoc command-name (included-of canvas) :test #'string-equal))

(defun concatenate-ps (canvas)
  "Concatenates the header and body postscript files of a postscript canvas ~
   together producing a single file that can be sent to a postscript ~
   printer."
  (let* ((file-name (body-full-pathname canvas))
         (header-file (header-full-pathname canvas))
         (postscript-file (postscript-file-full-pathname canvas))
         (xpixels (ps-width-of canvas))
         (ypixels (ps-height-of canvas))
         (line-max (max-procedure-lines-of canvas)))
    (cond
     ((and (<= (+ xpixels (* 2 (ps-horizontal-margin-of canvas))) *ps-paper-width*)
           (<= (+ ypixels (* 2 (ps-vertical-margin-of canvas))) *ps-paper-height*))
      (with-open-file (hfile header-file
                             :direction :output
                             :if-does-not-exist :create
                             :if-exists :append)
        (format hfile "~%ps_set_page_boundaries~%")
        (format hfile "~%canvas_horizontal_margin canvas_vertical_margin translate~%"))
      (with-open-file (filen file-name
                             :direction :output
                             :if-does-not-exist :create
                             :if-exists :append)
        (format filen "~%showpage"))
      (read-write header-file postscript-file)
      (read-write file-name postscript-file))
     (T
        (read-write header-file postscript-file)
        (with-open-file (pfile postscript-file
                               :direction :output
                               :if-does-not-exist :create
                               :if-exists :append)
          
          (let ((ps-name-list NIL)
                (ps-big-name-list NIL))
            (with-open-file (ifile file-name :direction :input)
              (loop
                with line = (read-line ifile NIL NIL)
                with count = 0
                with ps-name
                while line
                do
                (when (zerop count)
                  (setf ps-name (string (gensym "c_")))
                  (format pfile "/~a{~%ps_draw_dict begin~%" 
                          ps-name))
                
                (write-line line pfile)
                (incf count)
                (setf line (read-line ifile NIL NIL))
                
                (when (>= count line-max)
                  (setf count 0)
                  (format pfile  "~%end~%}def~%")
                  (push ps-name ps-name-list)
                  )
                
                (when (>= (length ps-name-list) line-max)
                  (setf ps-name (string (gensym "c_")))
                  (format pfile "/~a{~%ps_draw_dict begin~%" ps-name)
                  (loop for psn in (reverse ps-name-list)
                        do
                        (format pfile "~&~10T~a" psn))
                  (format pfile  "~%end~%}def~%")
                  (setf ps-name-list NIL)
                  (push ps-name ps-big-name-list))
                
                (when (>= (length ps-big-name-list) line-max)
                  (setf ps-name (string (gensym "c_")))
                  (format pfile "/~a{~%ps_draw_dict begin~%" ps-name)
                  (loop for psn in (reverse ps-big-name-list)
                        do
                        (format pfile "~&~10T~a" psn))
                  (format pfile  "~%end~%}def~%")
                  (setf ps-big-name-list (list ps-name)))
                
                finally  ;; tidy up
                
                (progn
                  (when (< count line-max)
                    (format pfile  "~%end~%}def~%")
                    (push ps-name ps-name-list))
                  (when ps-name-list
                    (setf ps-name (string (gensym "c_")))
                    (format pfile "/~a{~%ps_draw_dict begin~%" ps-name)
                    (loop for psn in (reverse ps-name-list)
                          do
                          (format pfile "~&~10T~a" psn))
                    (format pfile  "~%end~%}def~%")
                    (setf ps-name-list NIL)
                    (push ps-name ps-big-name-list))
                  (when ps-big-name-list
                    (setf ps-name (string (gensym "c_")))
                    (format pfile "/~a{~%ps_draw_dict begin~%gsave~%" ps-name)
                    (loop for psn in (reverse ps-big-name-list)
                          do
                          (format pfile "~&~10T~a" psn))
                    (format pfile  "~%grestore~%end~%}def~%")
                    (setf ps-big-name-list (list ps-name)))
                  (format pfile "~%{~a} ~A ~A redraw"
                          (first ps-big-name-list) xpixels ypixels)
                  )
                )  ;; end loop
              )))))))

(defun delete-header-file (canvas)
  (delete-file (header-full-pathname canvas)))

(defun delete-body-file (canvas)
  (delete-file (body-full-pathname canvas)))

(defun compute-ps-x-pages (canvas xpixels)
  "This function computes the number of pages which a large canvas requires in the x direction."
  (ceiling xpixels (- *ps-paper-width* (* 2 (ps-horizontal-margin-of canvas)))))

(defun compute-ps-y-pages (canvas ypixels)
  "This function computes the number of pages which a large canvas requires in the y direction."
  (ceiling ypixels (- *ps-paper-height* (* 2 (ps-vertical-margin-of canvas)))))

(defgeneric concatenate-page (canvas-or-header page &optional body ps-file page-prefix)
  (:documentation "This function is intended to generate workable postscript files for each~
                   page of a large canvas.  It accepts the following command lines:
     concatenate-page canvas page
     concatenate-page postscript-info page
     concatenate-page header-file body-file postscript-file postscript-page-prefix."))

(defmethod concatenate-page ((canvas postscript-canvas) page &optional body ps-file page-prefix)
  (declare (ignore body ps-file ;;page-prefix
                   ))
  (let  ((pagefilen (format nil "~a~a.ps" 
                            ;;(ps-page-full-prefix canvas)
                            page-prefix
                            page)))
    (read-write (header-full-pathname canvas) (postscript-file-full-pathname canvas))
    (read-write pagefilen (postscript-file-full-pathname canvas))
    (read-write (body-full-pathname canvas) (postscript-file-full-pathname canvas))))
  
(defmethod concatenate-page ((info postscript-info) page &optional body ps-file page-prefix)
  (declare (ignore body ps-file ;;page-prefix
                   ))
  (let  ((pagefilen (format nil "~a~a.ps"
                            ;;(ps-page-full-prefix info)
                            page-prefix
                            page)))
    (read-write (header-full-pathname info) (postscript-file-full-pathname info))
    (read-write pagefilen (postscript-file-full-pathname info))
    (read-write (body-full-pathname info) (postscript-file-full-pathname info))))

(defmethod concatenate-page ((header string) page &optional body ps-file page-prefix)
  (let ((pagefilen (format nil "~a~a.ps" page-prefix page)))
    (read-write header ps-file)
    (read-write pagefilen ps-file)
    (read-write body ps-file)))

(defun ps-set-pen-width (canvas width)
  "This function sets the line width on the postscript canvas."
  (let ((width (canvas-to-ps-pen-width canvas width)))
    (write-ps canvas setlinewidth width)))

(defun ps-set-pen-color (canvas color)
  "This function sets the RGB color on the postscript canvas."
  (let (
        (red (canvas-to-ps-red canvas (red-of color)))
        (green (canvas-to-ps-green canvas (green-of color)))
        (blue (canvas-to-ps-blue canvas (blue-of color))))
    (write-ps canvas setrgbcolor red green blue)))
